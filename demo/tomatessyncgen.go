package main

// file generated by
// github.com/mh-cbon/channeler
// do not edit

// TomatesSyncGen is channeled.
type TomatesSyncGen struct {
	embed TomatesGen
	ops   chan func()
	stop  chan bool
	tick  chan bool
}

// NewTomatesSyncGen constructs a channeled version of TomatesGen
func NewTomatesSyncGen() *TomatesSyncGen {
	ret := &TomatesSyncGen{
		ops:  make(chan func()),
		tick: make(chan bool),
		stop: make(chan bool),
	}
	go ret.Start()
	return ret
}

// Push is channeled
func (t *TomatesSyncGen) Push(x ...*Tomate) *TomatesGen {
	var retVar0 *TomatesGen
	t.ops <- func() {
		retVar0 = t.embed.Push(x...)
	}
	<-t.tick
	return retVar0
}

// Unshift is channeled
func (t *TomatesSyncGen) Unshift(x ...*Tomate) *TomatesGen {
	var retVar1 *TomatesGen
	t.ops <- func() {
		retVar1 = t.embed.Unshift(x...)
	}
	<-t.tick
	return retVar1
}

// Pop is channeled
func (t *TomatesSyncGen) Pop() *Tomate {
	var retVar2 *Tomate
	t.ops <- func() {
		retVar2 = t.embed.Pop()
	}
	<-t.tick
	return retVar2
}

// Shift is channeled
func (t *TomatesSyncGen) Shift() *Tomate {
	var retVar3 *Tomate
	t.ops <- func() {
		retVar3 = t.embed.Shift()
	}
	<-t.tick
	return retVar3
}

// Index is channeled
func (t *TomatesSyncGen) Index(s *Tomate) int {
	var retVar4 int
	t.ops <- func() {
		retVar4 = t.embed.Index(s)
	}
	<-t.tick
	return retVar4
}

// Contains is channeled
func (t *TomatesSyncGen) Contains(s *Tomate) bool {
	var retVar5 bool
	t.ops <- func() {
		retVar5 = t.embed.Contains(s)
	}
	<-t.tick
	return retVar5
}

// RemoveAt is channeled
func (t *TomatesSyncGen) RemoveAt(i int) bool {
	var retVar6 bool
	t.ops <- func() {
		retVar6 = t.embed.RemoveAt(i)
	}
	<-t.tick
	return retVar6
}

// Remove is channeled
func (t *TomatesSyncGen) Remove(s *Tomate) bool {
	var retVar7 bool
	t.ops <- func() {
		retVar7 = t.embed.Remove(s)
	}
	<-t.tick
	return retVar7
}

// InsertAt is channeled
func (t *TomatesSyncGen) InsertAt(i int, s *Tomate) *TomatesGen {
	var retVar8 *TomatesGen
	t.ops <- func() {
		retVar8 = t.embed.InsertAt(i, s)
	}
	<-t.tick
	return retVar8
}

// Splice is channeled
func (t *TomatesSyncGen) Splice(start int, length int, s ...*Tomate) []*Tomate {
	var retVar9 []*Tomate
	t.ops <- func() {
		retVar9 = t.embed.Splice(start, length, s...)
	}
	<-t.tick
	return retVar9
}

// Slice is channeled
func (t *TomatesSyncGen) Slice(start int, length int) []*Tomate {
	var retVar10 []*Tomate
	t.ops <- func() {
		retVar10 = t.embed.Slice(start, length)
	}
	<-t.tick
	return retVar10
}

// Reverse is channeled
func (t *TomatesSyncGen) Reverse() *TomatesGen {
	var retVar11 *TomatesGen
	t.ops <- func() {
		retVar11 = t.embed.Reverse()
	}
	<-t.tick
	return retVar11
}

// Len is channeled
func (t *TomatesSyncGen) Len() int {
	var retVar12 int
	t.ops <- func() {
		retVar12 = t.embed.Len()
	}
	<-t.tick
	return retVar12
}

// Set is channeled
func (t *TomatesSyncGen) Set(x []*Tomate) *TomatesGen {
	var retVar13 *TomatesGen
	t.ops <- func() {
		retVar13 = t.embed.Set(x)
	}
	<-t.tick
	return retVar13
}

// Get is channeled
func (t *TomatesSyncGen) Get() []*Tomate {
	var retVar14 []*Tomate
	t.ops <- func() {
		retVar14 = t.embed.Get()
	}
	<-t.tick
	return retVar14
}

// At is channeled
func (t *TomatesSyncGen) At(i int) *Tomate {
	var retVar15 *Tomate
	t.ops <- func() {
		retVar15 = t.embed.At(i)
	}
	<-t.tick
	return retVar15
}

// Filter is channeled
func (t *TomatesSyncGen) Filter(filters ...func(*Tomate) bool) *TomatesGen {
	var retVar16 *TomatesGen
	t.ops <- func() {
		retVar16 = t.embed.Filter(filters...)
	}
	<-t.tick
	return retVar16
}

// Map is channeled
func (t *TomatesSyncGen) Map(mappers ...func(*Tomate) *Tomate) *TomatesGen {
	var retVar17 *TomatesGen
	t.ops <- func() {
		retVar17 = t.embed.Map(mappers...)
	}
	<-t.tick
	return retVar17
}

// First is channeled
func (t *TomatesSyncGen) First() *Tomate {
	var retVar18 *Tomate
	t.ops <- func() {
		retVar18 = t.embed.First()
	}
	<-t.tick
	return retVar18
}

// Last is channeled
func (t *TomatesSyncGen) Last() *Tomate {
	var retVar19 *Tomate
	t.ops <- func() {
		retVar19 = t.embed.Last()
	}
	<-t.tick
	return retVar19
}

// Empty is channeled
func (t *TomatesSyncGen) Empty() bool {
	var retVar20 bool
	t.ops <- func() {
		retVar20 = t.embed.Empty()
	}
	<-t.tick
	return retVar20
}

// UnmarshalJSON is channeled
func (t *TomatesSyncGen) UnmarshalJSON(b []byte) error {
	var retVar21 error
	t.ops <- func() {
		retVar21 = t.embed.UnmarshalJSON(b)
	}
	<-t.tick
	return retVar21
}

// MarshalJSON is channeled
func (t *TomatesSyncGen) MarshalJSON() ([]byte, error) {
	var retVar22 []byte
	var retVar23 error
	t.ops <- func() {
		retVar22, retVar23 = t.embed.MarshalJSON()
	}
	<-t.tick
	return retVar22, retVar23
}

// Start the main loop
func (t *TomatesSyncGen) Start() {
	for {
		select {
		case op := <-t.ops:
			op()
			t.tick <- true
		case <-t.stop:
			return
		}
	}
}

// Stop the main loop
func (t *TomatesSyncGen) Stop() {
	t.stop <- true
}
