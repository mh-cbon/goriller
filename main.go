// Package goriller generate gorilla routers.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/loader"

	"github.com/mh-cbon/astutil"
)

var name = "goriller"
var version = "0.0.0"

func main() {

	var help bool
	var h bool
	var ver bool
	var v bool
	var outPkg string
	flag.BoolVar(&help, "help", false, "Show help.")
	flag.BoolVar(&h, "h", false, "Show help.")
	flag.BoolVar(&ver, "version", false, "Show version.")
	flag.BoolVar(&v, "v", false, "Show version.")
	// flag.StringVar(&outPkg, "p", "", "Package name of the new code.")

	flag.Parse()

	if ver || v {
		showVer()
		return
	}
	if help || h {
		showHelp()
		return
	}

	if flag.NArg() < 2 {
		panic("wrong usage")
	}
	args := flag.Args()

	pkgToLoad := getPkgToLoad()
	dest := os.Stdout

	o := args[0]
	restargs := args[1:]

	prog := astutil.GetProgram(pkgToLoad)
	pkg := prog.Package(pkgToLoad)

	foundMethods := astutil.FindMethods(pkg)

	if strings.Index(o, "/") > -1 {
		d := filepath.Dir(o)
		os.MkdirAll(d, os.ModePerm)
		outPkg = filepath.Base(d)
	} else if outPkg == "" {
		outPkg = os.Getenv("GOPACKAGE")
	}

	if o != "-" {
		f, err := os.Create(o)
		if err != nil {
			panic(err)
		}
		dest = f
		defer func() {
			f.Close()
			cmd := exec.Command("go", "fmt", args[0])
			cmd.Stdout = os.Stdout
			cmd.Stderr = os.Stderr
			cmd.Run()
		}()
	}

	fmt.Fprintf(dest, "package %v\n\n", outPkg)
	fmt.Fprintln(dest, `// file generated by`)
	fmt.Fprintf(dest, "// github.com/mh-cbon/%v\n", name)
	fmt.Fprintln(dest, `// do not edit`)
	fmt.Fprintln(dest, "")
	fmt.Fprintf(dest, "import (\n")
	// fmt.Fprintf(dest, "	%q\n", "io")
	fmt.Fprintf(dest, "	%q\n", "strings")
	fmt.Fprintf(dest, "	%q\n", "github.com/gorilla/mux")
	// fmt.Fprintf(dest, "	%v %q\n", "httper", "github.com/mh-cbon/httper/lib")
	fmt.Fprintf(dest, ")\n")
	fmt.Fprintf(dest, "\n\n")
	// cheat.
	fmt.Fprintf(dest, `var xxStringsSplit = strings.Split
	`)

	todos := checkArgs(restargs)
	for _, todo := range todos {
		res := processType(todo[1], todo[0], prog, pkg, foundMethods)
		io.Copy(dest, &res)
	}
}

func checkArgs(args []string) [][]string {
	ret := [][]string{}
	for _, todo := range args {
		y := strings.Split(todo, ":")
		if len(y) != 2 {
			panic("wrong name " + todo)
		}
		ret = append(ret, y)
	}
	return ret
}

func showVer() {
	fmt.Printf("%v %v\n", name, version)
}

func showHelp() {
	showVer()
	fmt.Println()
	fmt.Println("Usage")
	fmt.Println()
	fmt.Printf("	%v [out] [...types]\n\n", name)
	fmt.Printf("	out:   Output destination of the results, use '-' for stdout.\n")
	fmt.Printf("	types: A list of types such as src:dst.\n")
	fmt.Println()
}

func processType(destName, srcName string, prog *loader.Program, pkg *loader.PackageInfo, foundMethods map[string][]*ast.FuncDecl) bytes.Buffer {

	var b bytes.Buffer
	dest := &b

	srcConcrete := astutil.GetUnpointedType(srcName)
	structType := astutil.FindStruct(pkg, srcConcrete)
	structComment := astutil.GetComment(prog, structType.Pos())
	// todo: might do better to send only annotations or do other improvemenets.
	structComment = makeCommentLines(structComment)
	structAnnotations := astutil.GetAnnotations(structComment, "@")

	// Declare the new type
	fmt.Fprintf(dest, `
// %v is a goriller of %v.
%v
type %v struct{
	embed %v
  r *mux.Router
}
		`, destName, srcName, structComment, destName, srcName)

	// Make the constructor
	fmt.Fprintf(dest, `// New%v constructs a goriller of %v
func New%v(embed %v, r *mux.Router) *%v {
	ret := &%v{
		embed: embed,
    r: r,
	}
  return ret
}
`, destName, srcName, destName, srcName, destName, destName)

	fmt.Fprintf(dest, `// Make the given router.
func (t %v) Bind(router *mux.Router) {
`, destName)

	for _, m := range foundMethods[srcConcrete] {
		methodName := astutil.MethodName(m)

		comment := astutil.GetComment(prog, m.Pos())
		annotations := astutil.GetAnnotations(comment, "@")
		annotations = mergeAnnotations(structAnnotations, annotations)

		expr := ""
		if route, ok := annotations["route"]; ok {
			route = strings.TrimSpace(route)
			expr += fmt.Sprintf(`.HandleFunc(%q, t.embed.%v)`, route, methodName)
		}

		if name, ok := annotations["name"]; ok {
			name = strings.TrimSpace(name)
			expr += fmt.Sprintf(`.Name(%q)`, name)
		}
		if methods, ok := annotations["methods"]; ok {
			methods = strings.TrimSpace(methods)
			methods = commaArgsToSlice(methods)
			if methods != "" {
				expr += fmt.Sprintf(`.Methods(%v)`, methods)
			}
		}
		if schemes, ok := annotations["schemes"]; ok {
			schemes = strings.TrimSpace(schemes)
			schemes = commaArgsToSlice(schemes)
			if schemes != "" {
				expr += fmt.Sprintf(`.Schemes(%v)`, schemes)
			}
		}
		// if headers, ok := annotations["headers"]; ok {
		// 	headers = strings.TrimSpace(headers)
		// 	headers = commaArgsToSlice(headers)
		// 	if headers != "" {
		// 		expr += fmt.Sprintf(`.Headers(%v)`, headers)
		// 	}
		// }
		if host, ok := annotations["host"]; ok {
			host = strings.TrimSpace(host)
			if host != "" {
				expr += fmt.Sprintf(`.Host(%v)`, host)
			}
		}
		if expr != "" {
			fmt.Fprintf(dest, "router%v", expr)
		}
		fmt.Fprintln(dest)
	}

	fmt.Fprintf(dest, `
}`)

	return b
}

func mergeAnnotations(structAnnot, methodAnnot map[string]string) map[string]string {
	ret := map[string]string{}
	for k, v := range methodAnnot {
		ret[k] = v
	}
	for k, v := range structAnnot {
		if _, ok := ret[k]; !ok {
			ret[k] = v
		}
	}
	return ret
}

func makeCommentLines(s string) string {
	s = strings.TrimSpace(s)
	comment := ""
	for _, k := range strings.Split(s, "\n") {
		comment += "// " + k + "\n"
	}
	comment = strings.TrimSpace(comment)
	if comment == "" {
		comment = "//"
	}
	return comment
}

func commaArgsToSlice(s string) string {
	ret := ""
	for _, l := range strings.Split(s, ",") {
		l = strings.TrimSpace(l)
		ret += fmt.Sprintf("%q, ", l)
	}
	if ret != "" {
		ret = ret[:len(ret)-1]
	}
	return ret
}

func getPkgToLoad() string {
	gopath := filepath.Join(os.Getenv("GOPATH"), "src")
	pkgToLoad, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	return pkgToLoad[len(gopath)+1:]
}
